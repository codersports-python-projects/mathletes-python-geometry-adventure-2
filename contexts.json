{
    "project_design_approach_context_context": "Project Design Approach Context\n\nOverview:\nThis context defines the design approach for each coding project. It divides the development process into three distinct phases—Explore, Build, and Launch—to ensure that students build a solid conceptual foundation and then progressively integrate those skills into a complete, modular, multi-file project.\n\nPhase 1 – Explore (Lessons 1–3):\n• Focus: Introduce fundamental Python concepts through exercises that are purposefully aligned with the final project design. The exercises are not random; they are selected to build the skills and understanding that will directly feed into the project developed in later phases.\n• Files: Each lesson provides a standalone exercise file (exercise.py) that reinforces core topics relevant to the final project. For example:\n  - Lesson 1: Exercises on variables, data types, and basic input/output operations that will later be used in the main application.\n  - Lesson 2: Exercises on control structures (if/else, loops) and functions to lay the groundwork for the project’s logic.\n  - Lesson 3: Exercises on error handling, string operations, and basic data processing, which will be integrated into the final project code.\n• Outcome: Students gain a strong conceptual foundation that is directly applicable to the final project. They understand how each fundamental concept contributes to the overall design and functionality of the project.\n\nPhase 2 – Build (Lessons 4–6):\n• Focus: Assemble and integrate the project using a modular, multi-file structure.\n• Files:\n  - Root Directory Files: These include the final, complete versions of the project files (main.py, utils.py, features.py) that represent the fully functional project.\n  - Lesson Files: Each lesson in this phase provides an evolving version of main.py. In Lesson 4, students start with an initial scaffold of main.py; in Lesson 5, they integrate additional features (e.g., by calling functions from features.py); and in Lesson 6, they finalize main.py so it works seamlessly with the root files.\n• Outcome: By the end of this phase, students have built a fully operational version of the project that integrates the foundational concepts from the Explore phase into a coherent application.\n\nPhase 3 – Launch (Lessons 7–9):\n• Focus: Finalize, test, and enhance the project.\n• Files:\n  - Lesson Files: Each lesson in this phase provides an updated version of main.py, focusing on testing, code enhancements, and user interface improvements.\n• Outcome: Students refine and polish the project, ensuring it is robust, user-friendly, and ready for demonstration or deployment.\n\nAdditional Guidelines:\n• Alignment: All exercises in the Explore phase must be directly relevant to the final project design. Each exercise should serve as a building block that will eventually contribute to a cohesive, working application.\n• Consistency: The approach emphasizes modularity, incremental learning, and real-world project organization.\n• Audience: All content and tone should be engaging and age-appropriate for kids and teens (ages 10–14), in line with the Audience Style Context.",
    "main_py_context_context": "# Main.py Context\n\nThis context provides essential guidelines and best practices for generating Python scripts (`main.py`) for each lesson in the project. The generated `main.py` should:\n\n- Follow Python's PEP 8 style guidelines.\n- Include necessary imports based on lesson requirements.\n- Define functions and classes as specified in the lesson content.\n- Handle user inputs and outputs effectively.\n- Incorporate error handling where appropriate.\n- Be optimized for performance without sacrificing readability.\n\n**Additional Instructions:**\n\n- Ensure that the generated code is syntactically correct and free of syntax errors.\n- Include docstrings for all functions and classes.\n- Provide inline comments to explain complex logic or operations.\n- Structure the code to facilitate easy understanding and maintenance.",
    "project_key_concepts_context_context": "# Project Key Concepts\n\n## Fundamental Concepts\n\n1. **Variables and Data Types**\n   - Understanding and using different data types.\n   - Variable assignment and manipulation.\n\n2. **Control Structures**\n   - Conditional statements (`if`, `else`, `elif`).\n   - Loops (`for`, `while`).\n\n3. **Functions**\n   - Defining and invoking functions.\n   - Parameters and return values.\n\n4. **Data Structures**\n   - Lists, dictionaries, and tuples.\n   - Operations like indexing, slicing, and iteration.\n\n5. **Input/Output Operations**\n   - Using `input()` and `print()` for basic I/O.\n\n## Advanced Concepts (as applicable)\n\n- **File Handling**\n  - Reading from and writing to files.\n\n- **Error Handling**\n  - Using try-except blocks.\n\n- **Modules and Libraries**\n  - Importing and utilizing standard libraries.\n\n## Project-Specific Concepts\n\n- **[Add project-specific concepts here]**\n\n## Learning Outcomes\n\n- **Apply** programming concepts to build functional applications.\n- **Analyze** problems and develop appropriate solutions.\n- **Demonstrate** understanding through project completion.\n\n## Integration with Educational Frameworks\n\n- **PRIMM:**\n  - Predict, Run, Investigate, Modify, Make.\n\n- **EBL-Modified:**\n  - Explore, Build, Launch.",
    "coding_standards_context_context": "This context summarizes coding standards and best practices for the Python learning project, ensuring consistency and readability.\n\nGuidelines:\n\nStyle:\n\nFollow PEP 8 guidelines.\nUse 4 spaces per indentation level.\nLimit lines to a reasonable length (around 79-88 characters as appropriate).\nNaming Conventions:\n\nVariables and functions: snake_case.\nClasses: CamelCase.\nConstants: UPPERCASE_WITH_UNDERSCORES.\nStructure:\n\nInclude docstrings for all functions, classes, and modules.\nUse inline comments for clarity, especially in complex sections.\nOrganize code into modular functions and classes; each should have a single responsibility.\nFormatting Tools:\n\nUse Black for auto-formatting and Flake8 for linting.\nEnsure code is clear and easy to understand, especially given the limited debugging tools in the IDE.\nIDE Compatibility:\n\nUse only libraries supported by the Coder Sports IDE (e.g., math, random, datetime).\nWrite code that is optimized for a browser-based environment.\nThese streamlined guidelines ensure that the code remains clean, readable, and consistent throughout the project.",
    "audience_style_context_context": "**Audience Style Context**\n\nThis context provides guidelines for maintaining a tone and style that is engaging, clear, and age-appropriate for children and teenagers (ages 8–14). Use these guidelines in all generated content to ensure that it is friendly, accessible, and instructional and with a fun tone throughout.\n\n- **Tone & Voice:**  \n  - Write in a friendly and encouraging manner.  \n  - Use simple language and avoid overly technical jargon.  \n  - Provide clear and concise explanations that are easy to understand for a younger audience.\n  - Try to be fun, even include the occassional kid friendly funning joke, epecially related to the content.\n\n- **Instructional Style:**  \n  - Include step-by-step instructions where appropriate.  \n  - Use examples and analogies that are relatable to kids and teens.  \n  - Maintain an enthusiastic and supportive tone to motivate learners.\n\n- **Interactivity & Engagement:**  \n  - Encourage active participation through interactive elements such as user input and engaging activities.  \n  - Provide prompts that guide learners through problem solving and discovery.\n\n- **Consistency with Coding Standards:**  \n  - Ensure that code examples follow the coding standards (e.g., PEP 8, clear comments, modular code) to promote best practices while remaining accessible.  \n  - Balance technical accuracy with simplicity, ensuring that explanations are clear without being condescending.",
    "json_format_context_context": "All outputs must adhere to the following guidelines:\n\n**Return only a valid JSON object that complies with RFC8259.**\nDo not include any markdown code fences (e.g., no json or ).\nDo not include any extra text, explanations, or commentary outside of the JSON object.\nAll keys and string values must be properly escaped.\nFollow the exact schema provided in the prompt with no additional keys or modifications.\nEnsure that no extraneous whitespace or control characters are present.",
    "ide_limitations_context_context": "Coder Sports IDE Limitations Context\n\nThis context outlines the constraints and considerations related to the Coder Sports IDE used in the course. It ensures that all lesson content, code snippets, and interactive elements are compatible and optimized for the specified IDE environment.\n\nCurrent IDE Overview:\n- Coder Sports IDE Features:\n  - Ace Editor: A lightweight, browser-based code editor supporting syntax highlighting, autocompletion, and real-time collaboration.\n  - Pyodide & WebAssembly with PyScript: Allows running Python code directly in the browser without a backend server.\n  - Real-Time Collaboration: Facilitates interactive coding sessions among teachers and students.\n  - Interactive Outputs: Displays code execution results and visual outputs directly within the IDE interface.\n\nKey Limitations and Constraints:\n- Library Support:\n  - Supported Libraries Only: Only a subset of Python libraries compatible with Pyodide is available. For example, use libraries like math, random, and datetime. ** Avoid libraries requiring native extensions or those unsupported by Pyodide (e.g., turtle, tkinter)**.  You are encouraged to use python libraries that are supported by Pyodide, is a Python distribution for the browser and Node.js based on WebAssembly. Any pure Python package with a wheel available on PyPI is supported. Many packages with C extensions have also been ported for use with Pyodide. These include many general-purpose packages such as regex, pyyaml, lxml and scientific Python packages including numpy, pandas, scipy, matplotlib, and scikit-learn.\n  - Error Feedback: Error messages and stack traces may be less detailed compared to desktop IDEs, so code should be written with clarity and simplicity.\n- File Management:\n  - Limited File Operations: Advanced file handling (bulk operations, deep directory structures) is not supported.\n\nCoder Sports IDE Library Support\n\nThis section outlines the libraries that are supported in the latest version of Pyodide/PyScript for use within the Coder Sports IDE. It is essential to rely only on these libraries to ensure compatibility with the browser-based environment.\n\n1. Python Standard Library:\n   - Pyodide includes most of the Python standard library, so built-in modules are fully supported.\n\n2. Scientific and Data Libraries:\n   - NumPy: For numerical operations and array computing.\n   - Pandas: For data manipulation and analysis.\n   - SciPy: For scientific computing routines.\n   - Matplotlib: For plotting and visualization.\n   - Scikit-learn: For machine learning (with the understanding that performance and interactivity may vary).\n\n3. Additional Libraries:\n   - Sympy: For symbolic mathematics.\n   - NetworkX: For graph-based computations.\n   - Bokeh and Plotly: For interactive visualizations (to some extent).\n   - Requests-HTML: A lightweight alternative for making HTTP requests and parsing HTML in the browser.\n   - Other scientific packages covering statistics, optimization, and more.\n\n4. Package Management with micropip:\n   - Pyodide includes a package installer called micropip that allows installation of pure-Python wheels built for Pyodide. This means many additional pure-Python libraries may be available even if not included by default.\n\n5. Unsupported Libraries:\n   - Avoid libraries that depend on native C extensions or a full desktop environment.\n   - turtle: Typically relies on a graphical backend that isn’t available in the browser.\n   - tkinter: Depends on a native windowing system and is not supported.\n   - Any libraries with non-Pyodide-compatible native dependencies.\n\nBest Practices for Using the Coder Sports IDE:\n1. Use Supported Libraries: Always refer to the pre-approved list of Python libraries (e.g., math, random, datetime). Avoid unsupported libraries.\n2. Maintain Code Clarity: Write code that is clear and well-commented to compensate for the limited debugging tools.\n3. Modular Code Structure: Organize code into small, manageable modules to facilitate collaboration and reduce complexity.",
    "project_structure_context_context": "# Project Structure Context\n\nThis document outlines the standardized structure for all projects.\n\n## Directory Structure\n\n```\n<project_root>/\n├── <PHASE_NAME>/\n│   ├── <lesson_name>/\n│   │   ├── LESSON_OVERVIEW.md\n│   │   ├── LESSON_CONTENT.md\n│   │   ├── step1.md\n│   │   ├── step2.md\n│   │   ├── step3.md\n│   │   ├── main.py\n│   │   ├── solution.py\n│   │   ├── lesson_quiz.xml\n│   │   ├── lesson_intro_video_script.md\n│   │   ├── lesson_detailed_video_script.md\n│   ├── phase_intro.md\n│   ├── phase_quiz.xml\n│   ├── phase_intro_video_script.md\n├── README.md\n├── project_overview.md\n├── project_intro_video_script.md\n├── project_quiz.xml\n```\n**Notes:**\n\n- **`main.py`** and **`solution.py`** are included in each lesson directory.\n- The structure is designed to separate project levels clearly (project, phase, lesson).",
    "sample_project_solution_context_context": "# Sample Python Learning Project Solution\n\nThis context file provides sample `main.py` and `solution.py` files for each of the nine lessons in a **Generic Python Learning Project**. These samples serve as references to guide the generation of lesson-specific code, ensuring consistency and adherence to best practices.\n\n**Explanation of the `sample_project_solution.txt` Structure:**\n\n1. **Project Overview:**\n   - Provides a high-level description of the **Generic Python Application**, outlining its objectives and how it integrates various Python programming concepts.\n\n2. **Phases and Lessons:**\n   - **Phase 1: Explore**\n     - **Lesson 1:** Introduction to Python and Project Setup\n     - **Lesson 2:** Variables and Data Types\n     - **Lesson 3:** Control Structures - If Statements\n   - **Phase 2: Build**\n     - **Lesson 4:** Loops - While Loop\n     - **Lesson 5:** Functions\n     - **Lesson 6:** Lists and Dictionaries\n   - **Phase 3: Launch**\n     - **Lesson 7:** File Handling\n     - **Lesson 8:** Exception Handling\n     - **Lesson 9:** Modules and Packages\n\n3. **Code Samples:**\n   - Each lesson contains a `main.py` and a `solution.py`:\n     - **`main.py`:** Starter code intended for students to work on, introducing the lesson's core concepts.\n     - **`solution.py`:** Complete and correct implementation of the lesson's objectives, serving as a reference solution.\n\n4. **Final Project:**\n   - **`project_solution.py`:** A comprehensive script that integrates all lessons into a fully functional console-based application. This final project demonstrates how individual lessons come together to form a complete application, showcasing the application of learned concepts.\n\n5. **Consistency and Clarity:**\n   - **Uniform Structure:** Each lesson's files follow a consistent format, making it easy for students to follow along and compare their work with the solutions.\n   - **Commenting:** Code samples are well-commented to explain their functionality, enhancing understanding and readability.\n   - **Adherence to Best Practices:** Code follows PEP 8 guidelines, promoting good coding habits and maintaining professionalism.\n\n6. **Scalability and Modularity:**\n   - **Lesson Independence:** Each lesson builds upon the previous ones without requiring modifications to earlier lessons, allowing for easy updates and scalability.\n   - **Final Project Integration:** The final `project_solution.py` demonstrates how all lessons integrate into a single, cohesive application.\n\n## Project Overview: Generic Python Application\n\nThe Generic Python Application is a versatile project designed to introduce and reinforce fundamental Python programming concepts. This project progresses through three phases—**Explore**, **Build**, and **Launch**—each comprising three lessons that collectively guide students from basic syntax to developing a functional application.\n\n## Phase 1: Explore\n\n### Lesson 1: Introduction to Python and Project Setup\n\n#### main.py\n\n# main.py - Lesson 1: Introduction to Python and Project Setup\n\n```python\ndef main():\n    print(\"Welcome to the Generic Python Application!\")\n    print(\"Let's get started with Python programming.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### solution.py\n\n# solution.py - Lesson 1: Introduction to Python and Project Setup\n\n```python\ndef main():\n    print(\"Welcome to the Generic Python Application!\")\n    print(\"Let's get started with Python programming.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Lesson 2: Variables and Data Types\n\n#### main.py\n\n# main.py - Lesson 2: Variables and Data Types\n\n```python\n# Define variables of different data types\nuser_name = \"Alex\"\nage = 28\nheight = 5.8\nis_member = True\n\n# Display the variables\nprint(f\"Name: {user_name}\")\nprint(f\"Age: {age}\")\nprint(f\"Height: {height} feet\")\nprint(f\"Membership Status: {is_member}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 2: Variables and Data Types\n\n```python\n# Define variables of different data types\nuser_name = \"Alex\"\nage = 28\nheight = 5.8\nis_member = True\n\n# Display the variables\nprint(f\"Name: {user_name}\")             # Output: Name: Alex\nprint(f\"Age: {age}\")                    # Output: Age: 28\nprint(f\"Height: {height} feet\")         # Output: Height: 5.8 feet\nprint(f\"Membership Status: {is_member}\")# Output: Membership Status: True\n```\n\n### Lesson 3: Control Structures - If Statements\n\n#### main.py\n\n# main.py - Lesson 3: Control Structures - If Statements\n\n```python\nscore = int(input(\"Enter your score: \"))\n\nif score >= 90:\n    grade = 'A'\nelif score >= 80:\n    grade = 'B'\nelif score >= 70:\n    grade = 'C'\nelif score >= 60:\n    grade = 'D'\nelse:\n    grade = 'F'\n\nprint(f\"Your grade is: {grade}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 3: Control Structures - If Statements\n\n```python\nscore = int(input(\"Enter your score: \"))\n\nif score >= 90:\n    grade = 'A'\nelif score >= 80:\n    grade = 'B'\nelif score >= 70:\n    grade = 'C'\nelif score >= 60:\n    grade = 'D'\nelse:\n    grade = 'F'\n\nprint(f\"Your grade is: {grade}\")  # Example Output: Your grade is: B\n```\n\n## Phase 2: Build\n\n### Lesson 4: Loops - While Loop\n\n#### main.py\n\n# main.py - Lesson 4: Loops - While Loop\n\n```python\ncount = 1\nmax_count = 5\n\nwhile count <= max_count:\n    print(f\"Count: {count}\")\n    count += 1\n\nprint(\"Loop has ended.\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 4: Loops - While Loop\n\n```python\ncount = 1\nmax_count = 5\n\nwhile count <= max_count:\n    print(f\"Count: {count}\")  # Outputs: Count: 1 to Count: 5\n    count += 1\n\nprint(\"Loop has ended.\")       # Output: Loop has ended.\n```\n\n### Lesson 5: Functions\n\n#### main.py\n\n# main.py - Lesson 5: Functions\n\n```python\ndef greet(name):\n    return f\"Hello, {name}! Welcome to the Python Application.\"\n\ndef add_numbers(a, b):\n    return a + b\n\n# Using the functions\nuser = input(\"Enter your name: \")\nprint(greet(user))\n\nnum1 = float(input(\"Enter first number: \"))\nnum2 = float(input(\"Enter second number: \"))\nprint(f\"The sum is: {add_numbers(num1, num2)}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 5: Functions\n\n```python\ndef greet(name):\n    return f\"Hello, {name}! Welcome to the Python Application.\"\n\ndef add_numbers(a, b):\n    return a + b\n\n# Using the functions\nuser = input(\"Enter your name: \")              # Example Input: Alex\nprint(greet(user))                              # Output: Hello, Alex! Welcome to the Python Application.\n\nnum1 = float(input(\"Enter first number: \"))     # Example Input: 5\nnum2 = float(input(\"Enter second number: \"))    # Example Input: 7\nprint(f\"The sum is: {add_numbers(num1, num2)}\") # Output: The sum is: 12.0\n```\n\n### Lesson 6: Lists and Dictionaries\n\n#### main.py\n\n# main.py - Lesson 6: Lists and Dictionaries\n\n```python\n# List of fruits\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n# Dictionary of fruit prices\nfruit_prices = {\n    \"apple\": 0.99,\n    \"banana\": 0.59,\n    \"cherry\": 2.99,\n    \"date\": 3.49\n}\n\n# Display fruits and their prices\nfor fruit in fruits:\n    price = fruit_prices.get(fruit, \"Price not available\")\n    print(f\"{fruit.title()}: ${price}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 6: Lists and Dictionaries\n\n```python\n# List of fruits\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n# Dictionary of fruit prices\nfruit_prices = {\n    \"apple\": 0.99,\n    \"banana\": 0.59,\n    \"cherry\": 2.99,\n    \"date\": 3.49\n}\n\n# Display fruits and their prices\nfor fruit in fruits:\n    price = fruit_prices.get(fruit, \"Price not available\")\n    print(f\"{fruit.title()}: ${price}\")  # Outputs each fruit with its price\n```\n\n## Phase 3: Launch\n\n### Lesson 7: File Handling\n\n#### main.py\n\n# main.py - Lesson 7: File Handling\n\n```python\n# Writing to a file\nwith open(\"data.txt\", \"w\") as file:\n    file.write(\"Line 1: Python Programming\\n\")\n    file.write(\"Line 2: File Handling\\n\")\n    file.write(\"Line 3: Functions and Loops\\n\")\n\n# Reading from the file\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n    print(\"File Content:\")\n    print(content)\n```\n\n#### solution.py\n\n# solution.py - Lesson 7: File Handling\n\n```python\n# Writing to a file\nwith open(\"data.txt\", \"w\") as file:\n    file.write(\"Line 1: Python Programming\\n\")\n    file.write(\"Line 2: File Handling\\n\")\n    file.write(\"Line 3: Functions and Loops\\n\")\n\n# Reading from the file\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n    print(\"File Content:\")\n    print(content)  # Outputs the content of data.txt\n```\n\n### Lesson 8: Exception Handling\n\n#### main.py\n\n# main.py - Lesson 8: Exception Handling\n\n```python\ndef divide(a, b):\n    try:\n        result = a / b\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero.\")\n        return None\n    except TypeError:\n        print(\"Error: Invalid input type.\")\n        return None\n    else:\n        return result\n    finally:\n        print(\"Division operation completed.\")\n\n# Using the function\nnum1 = float(input(\"Enter numerator: \"))\nnum2 = float(input(\"Enter denominator: \"))\ndivision_result = divide(num1, num2)\n\nif division_result is not None:\n    print(f\"The result of division is: {division_result}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 8: Exception Handling\n\n```python\ndef divide(a, b):\n    try:\n        result = a / b\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero.\")\n        return None\n    except TypeError:\n        print(\"Error: Invalid input type.\")\n        return None\n    else:\n        return result\n    finally:\n        print(\"Division operation completed.\")\n\n# Using the function\nnum1 = float(input(\"Enter numerator: \"))    # Example Input: 10\nnum2 = float(input(\"Enter denominator: \"))  # Example Input: 2\ndivision_result = divide(num1, num2)        # Output: Division operation completed. \n                                             #         The result of division is: 5.0\n\n# Handling ZeroDivisionError\n# Example Input: 10 and 0\n# Output: Error: Cannot divide by zero.\n#         Division operation completed.\n```\n\n### Lesson 9: Modules and Packages\n\n#### main.py\n\n# main.py - Lesson 9: Modules and Packages\n\n```python\nimport math\nimport statistics\n\ndef calculate_statistics(data):\n    mean = statistics.mean(data)\n    median = statistics.median(data)\n    std_dev = math.sqrt(statistics.variance(data))\n    return mean, median, std_dev\n\n# Sample data\ndata_points = [10, 20, 20, 40, 50, 50, 50, 80, 90]\n\n# Calculate statistics\nmean, median, std_dev = calculate_statistics(data_points)\n\n# Display results\nprint(f\"Mean: {mean}\")\nprint(f\"Median: {median}\")\nprint(f\"Standard Deviation: {std_dev}\")\n```\n\n#### solution.py\n\n# solution.py - Lesson 9: Modules and Packages\n\n```python\nimport math\nimport statistics\n\ndef calculate_statistics(data):\n    mean = statistics.mean(data)\n    median = statistics.median(data)\n    std_dev = math.sqrt(statistics.variance(data))\n    return mean, median, std_dev\n\n# Sample data\ndata_points = [10, 20, 20, 40, 50, 50, 50, 80, 90]\n\n# Calculate statistics\nmean, median, std_dev = calculate_statistics(data_points)\n\n# Display results\nprint(f\"Mean: {mean}\")                # Output: Mean: 43.333333333333336\nprint(f\"Median: {median}\")            # Output: Median: 40\nprint(f\"Standard Deviation: {std_dev}\") # Output: Standard Deviation: 27.8567765543687\n```\n\n## Final Project: Complete `project_solution.py`\n\nBelow is the complete solution for the **Generic Python Application**, integrating all lessons into a functional console-based application. This final project demonstrates the application of variables, control structures, loops, functions, data structures, file handling, exception handling, and modules/packages.\n\n#### project_solution.py\n\n# project_solution.py - Complete Generic Python Application\n\n```python\nimport math\nimport statistics\n\ndef greet_user(name):\n    print(f\"Welcome, {name}, to the Generic Python Application!\")\n\ndef get_user_details():\n    user_name = input(\"Enter your name: \")\n    age = int(input(\"Enter your age: \"))\n    height = float(input(\"Enter your height in feet: \"))\n    is_member_input = input(\"Are you a member? (yes/no): \").strip().lower()\n    is_member = True if is_member_input == 'yes' else False\n    return user_name, age, height, is_member\n\ndef display_user_details(user_name, age, height, is_member):\n    print(f\"\\nUser Details:\")\n    print(f\"Name: {user_name}\")\n    print(f\"Age: {age}\")\n    print(f\"Height: {height} feet\")\n    print(f\"Membership Status: {is_member}\")\n\ndef determine_grade(score):\n    if score >= 90:\n        return 'A'\n    elif score >= 80:\n        return 'B'\n    elif score >= 70:\n        return 'C'\n    elif score >= 60:\n        return 'D'\n    else:\n        return 'F'\n\ndef loop_example(max_count):\n    count = 1\n    while count <= max_count:\n        print(f\"Loop Count: {count}\")\n        count += 1\n    print(\"Loop has ended.\\n\")\n\ndef add_numbers(a, b):\n    return a + b\n\ndef list_and_dict_example():\n    fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    fruit_prices = {\n        \"apple\": 0.99,\n        \"banana\": 0.59,\n        \"cherry\": 2.99,\n        \"date\": 3.49\n    }\n    print(\"Fruits and their prices:\")\n    for fruit in fruits:\n        price = fruit_prices.get(fruit, \"Price not available\")\n        print(f\"{fruit.title()}: ${price}\")\n    print()\n\ndef divide(a, b):\n    try:\n        result = a / b\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero.\")\n        return None\n    except TypeError:\n        print(\"Error: Invalid input type.\")\n        return None\n    else:\n        return result\n    finally:\n        print(\"Division operation completed.\\n\")\n\ndef calculate_statistics(data):\n    mean = statistics.mean(data)\n    median = statistics.median(data)\n    std_dev = math.sqrt(statistics.variance(data))\n    return mean, median, std_dev\n\ndef write_to_file(filename, content):\n    try:\n        with open(filename, \"w\") as file:\n            file.write(content)\n        print(f\"Successfully wrote to {filename}.\\n\")\n    except Exception as e:\n        print(f\"Error writing to file: {e}\\n\")\n\ndef read_from_file(filename):\n    try:\n        with open(filename, \"r\") as file:\n            content = file.read()\n        print(f\"Content of {filename}:\\n{content}\\n\")\n    except FileNotFoundError:\n        print(f\"Error: {filename} does not exist.\\n\")\n    except Exception as e:\n        print(f\"Error reading file: {e}\\n\")\n\ndef main():\n    # Lesson 1: Introduction\n    greet_user(\"User\")\n    \n    # Lesson 2: Variables and Data Types\n    user_name, age, height, is_member = get_user_details()\n    display_user_details(user_name, age, height, is_member)\n    \n    # Lesson 3: Control Structures\n    score = int(input(\"Enter your score to determine grade: \"))\n    grade = determine_grade(score)\n    print(f\"Your grade is: {grade}\\n\")\n    \n    # Lesson 4: Loops\n    loop_example(5)\n    \n    # Lesson 5: Functions\n    num1 = float(input(\"Enter first number to add: \"))\n    num2 = float(input(\"Enter second number to add: \"))\n    sum_result = add_numbers(num1, num2)\n    print(f\"The sum of {num1} and {num2} is: {sum_result}\\n\")\n    \n    # Lesson 6: Lists and Dictionaries\n    list_and_dict_example()\n    \n    # Lesson 7: File Handling\n    write_to_file(\"data.txt\", \"Line 1: Python Programming\\nLine 2: File Handling\\nLine 3: Functions and Loops\")\n    read_from_file(\"data.txt\")\n    \n    # Lesson 8: Exception Handling\n    num3 = float(input(\"Enter numerator for division: \"))\n    num4 = float(input(\"Enter denominator for division: \"))\n    division_result = divide(num3, num4)\n    if division_result is not None:\n        print(f\"The result of division is: {division_result}\\n\")\n    \n    # Lesson 9: Modules and Packages\n    data_points = [10, 20, 20, 40, 50, 50, 50, 80, 90]\n    mean, median, std_dev = calculate_statistics(data_points)\n    print(f\"Statistics of the data points:\")\n    print(f\"Mean: {mean}\")\n    print(f\"Median: {median}\")\n    print(f\"Standard Deviation: {std_dev}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "learning_framework_context_context": "This context provides a concise overview of the educational frameworks that guide lesson plan development.\n\n## Frameworks:\n\n### PRIMM:\n\nPredict: Have students anticipate code behavior.\nRun: Execute code and observe results.\nInvestigate: Analyze differences between expectation and outcome.\nModify: Adjust code based on findings.\nMake: Create original projects using learned concepts.\n\n### EBL-Modified (Explore, Build, Launch):\n\nExplore: Introduce and investigate new concepts.\nBuild: Guide students in constructing projects incrementally.\nLaunch: Finalize and present projects, reinforcing learning through reflection.\nUse these frameworks to structure lesson content, ensuring clear progression and practical application.\n\n## Educational Principles:\n\n### 1. **Constructivism:**\nPromotes active learning by encouraging students to construct their own understanding through hands-on activities, problem-solving, and real-world applications. Learners build new knowledge upon their existing cognitive structures.\n\n### 2. **Bloom's Taxonomy:**\nEnsures that learning objectives encompass a range of cognitive processes, from basic knowledge and comprehension to higher-order skills like analysis, synthesis, and evaluation. This hierarchical model facilitates the development of critical thinking and problem-solving abilities.\n\n### 3. **Differentiated Instruction:**\nAcknowledges the diverse learning styles, paces, and interests of students by providing varied instructional methods and materials. This approach aims to meet individual learner needs, fostering an inclusive and supportive learning environment.\n\n### 4. **Assessment for Learning (Formative Assessment):**\nIntegrates ongoing assessments to monitor student progress, provide timely feedback, and inform instructional adjustments. Formative assessments help identify areas of strength and those requiring additional support, guiding personalized learning pathways.\n\n## Learning Outcomes:\n\n### 1. **Knowledge Acquisition:**\n- **Objective:** Grasp fundamental Python concepts, syntax, and programming paradigms.\n- **Outcome:** Students can accurately write and interpret Python code, understanding core programming constructs.\n\n### 2. **Skill Development:**\n- **Objective:** Apply Python skills to design, develop, and debug projects.\n- **Outcome:** Students can create functional programs, troubleshoot errors, and implement efficient solutions to complex problems.\n\n### 3. **Critical Thinking:**\n- **Objective:** Analyze and evaluate code for efficiency, readability, and effectiveness.\n- **Outcome:** Students can assess their own and others' code, identifying areas for improvement and optimizing performance.\n\n### 4. **Creativity and Innovation:**\n- **Objective:** Utilize programming skills to develop original projects and solutions.\n- **Outcome:** Students demonstrate creativity by designing unique applications, games, or tools that solve real-world problems.\n\n### 5. **Collaboration and Communication:**\n- **Objective:** Work effectively in teams, utilizing the collaborative features of the Coder Sports IDE.\n- **Outcome:** Students can collaborate on codebases, share insights, and communicate ideas clearly within a team setting.\n\n### 6. **Adaptability and Resilience:**\n- **Objective:** Adapt to new challenges and persist through problem-solving scenarios.\n- **Outcome:** Students exhibit resilience by overcoming obstacles, learning from mistakes, and iteratively improving their projects.\n\n## Integration with Coder Sports IDE:\n\n### 1. **Real-Time Collaboration:**\nLeverage the Coder Sports IDE’s real-time code collaboration features to facilitate peer learning, mentorship, and team-based projects. This fosters a community of practice where students can learn from one another and develop interpersonal skills alongside technical competencies.\n\n### 2. **Interactive Code Execution:**\nUtilize the IDE’s ability to run Python code directly in the browser via Pyodide and PyScript. This immediate feedback loop supports the PRIMM cycle, enabling students to quickly test hypotheses, observe outcomes, and refine their understanding through active experimentation.\n\n### 3. **Visual and Interactive Learning:**\nIncorporate visual outputs and interactive elements within lessons to enhance engagement and comprehension. Visual representations of data structures, algorithms, and program flows aid in the internalization of abstract concepts.\n\n### 4. **Project-Based Learning:**\nAlign lessons with the EBL-Modified framework by structuring content around project milestones—exploration, building, and launching. This approach ensures that students apply theoretical knowledge in practical contexts, culminating in tangible projects that showcase their learning journey.\n\n### 5. **Scaffolded Learning:**\nProvide scaffolded support through guided tutorials, code snippets, and incremental challenges that build upon each other. This strategy helps students gradually develop competence and confidence in their programming abilities.\n\n## Best Practices for Lesson Design:\n\n### 1. **Align Objectives with Frameworks:**\nEnsure that each lesson’s objectives are mapped to the PRIMM and EBL-Modified frameworks, facilitating a cohesive and structured learning progression.\n\n### 2. **Incorporate Formative Assessments:**\nEmbed quizzes, code reviews, and reflective activities within lessons to continuously assess and support student learning.\n\n### 3. **Foster an Inclusive Learning Environment:**\nDesign lessons that accommodate diverse learning needs and backgrounds, promoting equity and accessibility in educational opportunities.\n\n### 4. **Encourage Reflection and Iteration:**\nPromote reflective practices where students evaluate their learning experiences, identify areas for improvement, and iterate on their projects based on feedback and self-assessment.\n\n### 5. **Integrate Technology Thoughtfully:**\nUse the technological capabilities of the Coder Sports IDE to enhance, not distract from, the learning experience. Ensure that technology serves pedagogical goals and supports effective learning strategies.",
    "scaffolding_context_context": "# Scaffolding Context\n\nThis project follows a scaffolding approach to ensure students receive structured support as they learn. The key principles of scaffolding are applied throughout all lessons, ensuring that students can gradually build their knowledge and confidence.\n\n## Key Elements of Scaffolding:\n\n1. **Structured Support**: \n    - In the early lessons, students are provided with detailed explanations, step-by-step instructions, and hints. This support gradually decreases as students become more proficient.\n    - Initially, each code section will include explanatory comments, hints for the next steps, and guidance on where to look for potential errors.\n\n2. **Gradual Complexity**: \n    - Lessons start with simple coding tasks and gradually introduce more complex problems. \n    - As students progress, the complexity of the tasks increases, requiring them to apply the skills they’ve learned in previous lessons.\n\n3. **Contextual Hints**: \n    - Each lesson includes a series of contextual hints that are provided when the student encounters a challenging section of code.\n    - In later lessons, these hints will become less frequent, requiring the student to rely more on their own problem-solving skills.\n\n4. **Assessing Readiness**: \n    - Quizzes and investigation tasks are provided after each lesson to assess the student's understanding.\n    - These assessments help ensure that students are ready to move on to the next phase of the project. If necessary, review tasks are provided to reinforce key concepts.\n\n## Application of Scaffolding:\n\n- In the **EXPLORE** phase, students are given ample support, with fully functional code and detailed explanations.\n- In the **BUILD** phase, the amount of support is reduced. Students are guided to apply their knowledge and work through the coding steps with fewer hints.\n- By the **LAUNCH** phase, students are expected to work more independently, building their own code and solving problems with minimal guidance.\n\nThe scaffolding approach ensures that by the end of the project, students can confidently apply their knowledge to new challenges without needing step-by-step instructions.",
    "complexity_level_context_context": "This context defines how lesson content, instructional details, and code scaffolding should be tailored based on the user-selected complexity level. It references the detailed \"Python Concepts by Complexity\" structure and applies the following guidelines:\n\n** Complexity Level A (Basic): **\n\nTarget Audience: Beginners with little to no prior programming experience.\nContent Style: Very clear, step-by-step instructions with extensive scaffolding.\nFocus: Fundamental Python concepts with simplified examples and thorough guidance.\nExpected Detail: Comprehensive hints, detailed comments, and explicit instructions.\nReference: Concepts such as Variables and Data Types, Basic I/O, Simple Arithmetic, Control Structures, Introduction to Functions, Basic String Operations, Commenting, and Simple Programs.\n\n** Complexity Level AA (Intermediate): **\n\nTarget Audience: Learners with foundational programming knowledge ready to delve deeper.\n\nContent Style: Moderately detailed explanations that balance guidance with opportunities for independent problem solving.\n\nFocus: Core Python concepts with moderate complexity, introducing topics like advanced control structures, loop control, data structures (lists, dictionaries, tuples), functions, basic error handling, string formatting, modules, file I/O, list comprehensions, and optional data visualization.\n\nExpected Detail: Adequate scaffolding with hints provided where necessary, yet encouraging autonomous thinking.\n\n** Complexity Level AAA (Advanced): **\n\nTarget Audience: Learners with solid programming foundations, ready for more advanced topics.\nContent Style: Concise instructions with minimal scaffolding that promote deeper exploration and self-reliance.\nFocus: Advanced Python topics including advanced data structures, advanced functions (lambda, recursion, higher-order functions), comprehensive file handling, modules and packages, object-oriented programming (OOP), advanced error handling, decorators and generators, advanced iteration techniques, regular expressions, external libraries, concurrency and parallelism, environment management, optional networking, software development practices, and debugging techniques.\n\nExpected Detail: Reduced hints and scaffolding; technical explanations provided only where necessary to challenge and extend student knowledge.\n=======\n**Complexity Level Context**  \nThis context defines how lesson content, instructional details, and code scaffolding should be tailored based on the user-selected complexity level. It references the detailed \"Python Concepts by Complexity\" structure and applies the following guidelines:\n\n- **For Complexity Level A (Basic):**  \n  - **Target Audience:** Beginners with little to no prior programming experience.  \n  - **Content Style:** Very clear, step-by-step instructions with extensive scaffolding.  \n  - **Focus:** Fundamental Python concepts with simplified examples and thorough guidance.  \n  - **Expected Detail:** Comprehensive hints, detailed comments, and explicit instructions.  \n  - **Reference:** Concepts such as Variables and Data Types, Basic I/O, Simple Arithmetic, Control Structures, Introduction to Functions, Basic String Operations, Commenting, and Simple Programs.\n\n- **For Complexity Level AA (Intermediate):**  \n  - **Target Audience:** Learners with foundational programming knowledge ready to delve deeper.  \n  - **Content Style:** Moderately detailed explanations that balance guidance with opportunities for independent problem solving.  \n  - **Focus:** Core Python concepts with moderate complexity, introducing topics like advanced control structures, loop control, data structures (lists, dictionaries, tuples), functions, basic error handling, string formatting, modules, file I/O, list comprehensions, and optional data visualization.  \n  - **Expected Detail:** Adequate scaffolding with hints provided where necessary, yet encouraging autonomous thinking.\n\n- **For Complexity Level AAA (Advanced):**  \n  - **Target Audience:** Learners with solid programming foundations, ready for more advanced topics.  \n  - **Content Style:** Concise instructions with minimal scaffolding that promote deeper exploration and self-reliance.  \n  - **Focus:** Advanced Python topics including advanced data structures, advanced functions (lambda, recursion, higher-order functions), comprehensive file handling, modules and packages, object-oriented programming (OOP), advanced error handling, decorators and generators, advanced iteration techniques, regular expressions, external libraries, concurrency and parallelism, environment management, optional networking, software development practices, and debugging techniques.  \n  - **Expected Detail:** Reduced hints and scaffolding; technical explanations provided only where necessary to challenge and extend student knowledge.\n\n**Instructions:**  \nWhen generating any lesson plans, code examples, or instructional materials, reference this Complexity Level Context to ensure that the output is appropriately tailored to the specified complexity level (A, AA, or AAA). For complete details on the core concepts for each level, refer to the provided JSON file (`python_concepts_by_complexity.json`), which contains the full breakdown of target audiences and core topics for each level.",
    "project_a_testing_guidelines_context_context": "# Testing Guidelines\n\n1. Outline simple strategies for writing test cases and validating functionality.\n2. Provide examples of basic unit tests or input/output scenarios.\n3. Emphasize the importance of testing edge cases and error conditions.\n4. Encourage writing tests that are easy to understand and maintain.\n5. Suggest a checklist for testing key functionalities of the project.",
    "project_a_fun_and_engagement_context_context": "# Fun and Engagement Guidelines\n\n1. Provide ideas for incorporating playful elements or themes in projects.\n2. Suggest ways to gamify coding exercises, such as using challenges or rewards.\n3. Encourage creative twists that make projects more relatable and exciting for kids.\n4. Recommend including interactive prompts or mini-games within the project.\n5. Emphasize storytelling and visual elements that engage young learners.",
    "project_a_pseudocode_guidelines_context_context": "# Pseudocode Guidelines\n\n1. Structure your pseudocode in clear, sequential steps:\n   - Begin with high-level steps and break them down into sub-steps as needed.\n2. Use numbered steps (e.g., 1, 2, 3, …) for the main logic and indented bullet points for nested actions.\n3. Write in simple, plain language that is easy for beginners to understand.\n4. Clearly describe the purpose of each step:\n   - For example, \"Initialize variables for user input\" or \"Check if the user's guess is correct.\"\n5. Ensure your pseudocode covers all key aspects:\n   - Initialization and setup\n   - Input processing and decision points (e.g., conditional statements)\n   - Loops or iterations (e.g., for retrying a user guess)\n   - Function calls and their intended outcomes\n6. Provide brief examples within steps if possible:\n   - Example: \"If condition A is true, then proceed to step 3; otherwise, repeat step 2.\"",
    "project_a_assessment_criteria_context_context": "# Assessment Criteria Guidelines\n\n1. Define clear, age-appropriate objectives for project work.\n2. Outline a simple rubric that includes:\n   - Understanding of core concepts.\n   - Correct application of programming logic.\n   - Code readability and documentation.\n   - Creativity and problem-solving skills.\n3. Provide checkpoints for self-assessment during project development.\n4. Suggest formative assessment methods, such as quizzes or mini-project reviews.\n5. Emphasize constructive feedback that helps learners improve.",
    "project_a_deployment_guidelines_context_context": "# Deployment Guidelines\n\n1. Describe how to set up and run the project within the Coder Sports IDE.\n2. Provide instructions for managing files in a browser-based environment:\n   - How to save, open, and organize files.\n3. Outline the expected runtime behavior:\n   - How interactive outputs will be displayed.\n4. List any limitations regarding file operations or library support.\n5. Include troubleshooting tips for common deployment issues.",
    "project_a_pedagogical_tips_context_context": "# Pedagogical Tips Guidelines\n\n1. Explain complex programming concepts using simple analogies and examples.\n2. Suggest ways to break down problems into smaller, manageable parts.\n3. Encourage a step-by-step learning approach and provide scaffolded hints.\n4. Include tips for educators on how to facilitate discussions and engage students.\n5. Emphasize the importance of active learning through hands-on practice and reflection.\n6. Offer suggestions for follow-up activities or questions to deepen understanding.",
    "project_a_collaboration_guidelines_context_context": "# Collaboration Guidelines\n\n1. Outline best practices for pair programming and group work:\n   - Communicate clearly and listen actively.\n   - Divide tasks based on individual strengths.\n2. Provide tips for effective code reviews and sharing ideas.\n3. Encourage the use of the IDE’s real-time collaboration features.\n4. Suggest strategies for conflict resolution and constructive criticism.\n5. Emphasize the benefits of teamwork in problem solving and learning.",
    "project_a_documentation_style_context_context": "# Documentation Style Guidelines\n\n1. Use clear and concise language for all code comments and documentation.\n2. Maintain a consistent tone that is friendly and accessible to beginners.\n3. Include inline comments to explain complex code segments.\n4. Provide examples of well-documented code for reference.\n5. Emphasize the importance of updating documentation as code evolves.\n6. Recommend using markdown for external documentation (e.g., README files).",
    "project_a_error_handling_context_context": "# Error Handling Guidelines\n\n1. Write error messages in plain, beginner-friendly language:\n   - Avoid technical jargon; for example, say \"Invalid input. Please try again.\" instead of a complex error code.\n2. Provide actionable advice in error messages:\n   - Include suggestions such as \"Check that you entered a number between 1 and 10\" or \"Ensure your input is not empty.\"\n3. Use try/except blocks effectively:\n   - Catch potential errors and handle them gracefully without crashing the program.\n4. Log detailed error information internally (for debugging) but display only the essential, user-friendly message.\n5. Include inline comments to explain why specific error-handling measures are used:\n   - This helps learners understand the rationale behind defensive programming.\n6. Encourage testing:\n   - Remind developers to write test cases that simulate common error scenarios.",
    "project_a_architecture_guidelines_context_context": "# Architecture Guidelines\n\n1. Define the role of each module clearly:\n   - main.py: Responsible for application initialization, user input handling, and orchestrating the flow.\n   - utils.py: Contains helper functions, common utilities, and code that supports the main logic.\n   - features.py: Implements additional interactive features and integrates with main.py to enhance functionality.\n2. Specify how modules interact:\n   - Describe the data passed between modules, including inputs and expected outputs.\n   - Outline function interfaces and any shared data structures.\n3. Recommend design patterns that promote clarity and modularity:\n   - For instance, use a modular structure that separates core logic from helper functions.\n4. Consider the limitations of the Coder Sports IDE:\n   - Ensure the architecture avoids unsupported libraries and respects file operation constraints.\n5. Provide a textual flow or diagram explanation:\n   - Include a brief narrative or bullet list explaining the flow from initialization in main.py to the utility functions in utils.py and the additional features in features.py.\n6. Use clear, concise language while providing sufficient detail to serve as a blueprint for code generation.",
    "dynamic_context": "# Mathletes Context\n\nMathletes is a specialized program within Python camps that combines mathematical problem-solving with Python programming. Participants in Mathletes engage in projects that require the application of mathematical concepts and computational thinking to develop solutions and tools that address complex numerical challenges.\n\nKey Focus Areas:\n- **Mathematical Modeling:** Creating Python programs that model real-world mathematical scenarios, such as simulations of natural phenomena or financial calculations.\n- **Algorithm Development:** Designing and implementing algorithms to solve mathematical problems, including sorting, searching, and optimization tasks.\n- **Data Analysis and Visualization:** Developing tools to analyze mathematical data and visualize results using Python libraries like Matplotlib or Pandas.\n- **Computational Geometry:** Building applications that handle geometric computations, such as calculating areas, volumes, or handling spatial data.\n- **Problem-Solving Projects:** Engaging in projects that require logical reasoning and critical thinking to address and solve mathematical challenges.\n\nExcluded Focus Areas:\n- **Pure Theoretical Mathematics:** Projects should focus on applied mathematics and computational implementations rather than purely theoretical explorations.\n- **Advanced Mathematical Concepts:** Topics requiring specialized mathematical knowledge beyond the Python programming level are outside the scope.\n\nBy integrating Python programming with mathematical principles, Mathletes cultivates analytical thinking, precision, and creativity, empowering young learners to leverage technology in solving mathematical problems.\n"
}